/*
    handshaking.c 
    Created on: oct 3, 2024
    Author : Abdelrahman Ibrahim

*/

#include"handshaking.h"


/*
   * 1- client hello : tls version  , cryptoAlgo(RSA and AES) , random variables and hashing
   * 2- server hello : cryptoAgrement , session id and server's digital signature (hash the message then encrypt using private key)
   * 3- client check server's digital signature using server's public key
   * 4- key generation
   * 5- finish message from server and client
*/

unsigned long int global_n , global_e , global_d;




void clientHello(client_hello_t * client_hello_mes){
    /*this printf function will be replaced by the communication 
    protocol interface using in TLS*/
    PRNG  randonSeeds;
    init_prng(&randonSeeds , CLIENT_INIT_SEED);
    /*generate rondom numbers to be exchanged between server and client*/
    for(unsigned char i = 0 ; i < 16 ; i++){
        client_hello_mes->client_random[i] = (unsigned char)next_prng(&randonSeeds , MODULO_32); 
    }
}

void servevrHello(unsigned char * serverMessage ,signature_message_server_t  * server_hello_mes){
    unsigned long long int tempHash[32];
    unsigned char hashed_sever_message[32];
    for(unsigned char i = 0 ; i < 16 ; i++){
        server_hello_mes->server_hello_message[i] = serverMessage[i];
    }
    PRNG  randonSeeds;
    init_prng(&randonSeeds , SERVER_INIT_SEED);
    /*generate rondom numbers to be exchanged between server and client*/
    for(unsigned char i = 0 ; i < 16 ; i++){
        server_hello_mes->server_random[i] = (unsigned char)next_prng(&randonSeeds , MODULO_32); 
    }
    /*calculate the hash of the message*/
    sha256_block sha_block;
    sha256_init(&sha_block);
    sha256_update(&sha_block, (BYTE *)server_hello_mes->server_hello_message, 16);
    sha256_final(&sha_block, hashed_sever_message);
    for(unsigned char i = 0 ; i < 32 ; i++){
        tempHash[i] = hashed_sever_message[i];
    }

   /* encrypt the hash using RSA with private key*/
    unsigned long int  e , n  , d;
    generate_key(&e , &n);
    generatePrivateKey(e , &d);
    global_e = e; //public key of server
    global_n = n;
    global_d = d;
    rsaEncryption(server_hello_mes->encrypted_hashed_message ,  tempHash , d , n); //encrypt with the private key
}

unsigned char clientCheckDigitalSignature(signature_message_server_t * server_message ,
		signature_message_client_t * client_message){
    /*decrypt hash message with server public key and get the hash (suppose validation authority accept the puplic key)
    * calculate the hash of server message
    * compare the hashed value that decrypt with calculated one
    *  if the same value return 1 if not return 0
    */
    unsigned char hashed_sever_message[32] , tempHashed[32];
    unsigned char flag = 1;
    uint64_t temp[32];
    rsadecryption(server_message->encrypted_hashed_message , temp ,PRIVATE_KEY , PRIVATE_N);
    for(unsigned char i = 0 ; i < 32 ; i++){
        tempHashed[i] = temp[i];
    }
    sha256_block sha_block;
    sha256_init(&sha_block);
    sha256_update(&sha_block , (BYTE *)server_message->server_hello_message , 16);
    sha256_final(&sha_block , hashed_sever_message);
    /*compare between decrypted hash and calculated hash*/
    for(unsigned char i = 0 ; i <32 ; i++){
        if(hashed_sever_message[i] != tempHashed[i]) flag = 0;
    }
    return flag;
}


/*generated by the client*/
void generatePreMasterKey(unsigned char pre_master_key[48] ,
		unsigned long long int encrypted_pre_master_key[48]){
    /*firstly genrate 48 random Bytes*/
    unsigned long long int random_pre_master_key[48];
    PRNG  randonSeeds;
    init_prng(&randonSeeds , PRE_MASTER_SEED);
    /*generate rondom numbers to be exchanged between server and client*/
    for(unsigned char i = 0 ; i < 48 ; i++){
    	pre_master_key[i] = (unsigned char)next_prng(&randonSeeds , MODULO_32);
    }
    /*encrypt the pre master key using server's public key*/
    rsaEncryption(encrypted_pre_master_key , pre_master_key , global_e , global_n);
}


void generateMasterKey(unsigned char pre_master_key[48] , unsigned char random_key[16] , unsigned char master_key[HMAC_BLOCK_SIZE]){
    /*get a random key from random keys generated in the handshaking*/
    /*make HMAC using random data and pre master key to generate the master key*/
    hmac(master_key , pre_master_key , 48 , random_key , 16);
}


void generateSessionKeys(unsigned char master_key[HMAC_BLOCK_SIZE] , unsigned char random_seed[16] ,
 unsigned char session_keys[SESION_KEYS_NUMBERS][SESSION_KEY_SIZE]){
    unsigned char second_level_seed[32];
    unsigned char mac_secret_keys[32];
    unsigned char aes_secret_keys[32];
    hmac(second_level_seed , random_seed , 16 , master_key , HMAC_BLOCK_SIZE);
    /*generate MAC SESSION keys*/
    hmac(mac_secret_keys , second_level_seed , HMAC_BLOCK_SIZE , master_key , HMAC_BLOCK_SIZE);
    /*generte AES SESSION KEYS*/
    /*first level*/
    hmac(second_level_seed , second_level_seed , HMAC_BLOCK_SIZE , master_key , HMAC_BLOCK_SIZE);
    /*second level*/
    hmac(aes_secret_keys , second_level_seed , HMAC_BLOCK_SIZE , master_key , HMAC_BLOCK_SIZE);
    /*filling the gobal 2d array of session keys*/

    /*fill mac keys arrays*/
    /*client mac session key*/
    for(unsigned char i = 0 ; i < SESSION_KEY_SIZE ; i++){
        session_keys[CLIENT_MAC_SESSION_KEY][i] = mac_secret_keys[i];
    }
    /*server mac session key*/
    for(unsigned char i = 0 ; i < SESSION_KEY_SIZE ; i++){
        session_keys[SERVER_MAC_SESSION_KEY][i] = mac_secret_keys[i+16];
    }

    /*fill aes keys arrays*/
    /*client mac session key*/
    for(unsigned char i = 0 ; i < SESSION_KEY_SIZE ; i++){
        session_keys[CLIENT_AES_SESSION_KEY][i] = aes_secret_keys[i];
    }
    /*server mac session key*/
    for(unsigned char i = 0 ; i < SESSION_KEY_SIZE ; i++){
        session_keys[SERVER_AES_SESSION_KEY][i] = aes_secret_keys[i+16];
    }    
}
